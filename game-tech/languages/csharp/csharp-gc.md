# GC

## 容易产生 GC 的代码

代码每帧都在运行，同时分配临时堆内存。容易 GC，需要尽可能避免。

### 装箱

值类型隐式转换为引用类型时，将会隐式分配临时内存保存值类型

#### 常出现在
- 结构体隐式转换为接口，接口是引用类型，触发装箱
	- 特别体现在 Enumerable 创建 Enumerator 返回 IEnumerator， 如果 Enumerator 是结构体就会触发
- 结构体隐式转换为 object 会装箱
- typeof（T） 返回 Type 会产生类实例，避免装箱要用模板
- 结构体在不重写 GetHashCode 和 Equals 等默认方法的情况下调用这些默认方法，将会自动装箱为 System.Object 类型，并调用 System.Object 相应方法
- 
- 方法传入委托
	- 有名方法传入委托会装箱，因为他是方法指针
	- 匿名方法不会装箱，因为他提前已经装箱好了方法指针
	- 但是匿名方法（非静态）用到了方法外部变量，会对该变量装箱
	- 所以多使用匿名方法

### new

每帧的显示分配内存也会装箱

#### 解决方法

核心思路是对象（空间）复用

- 使用 List.Clear 代替 new List()
- 使用对象池


